defmodule RubberDuck.Repo.Migrations.CreatePlanningTables do
  @moduledoc """
  Updates resources based on their most recent snapshots.

  This file was autogenerated with `mix ash_postgres.generate_migrations`
  """

  use Ecto.Migration

  def up do
    create table(:validations, primary_key: false) do
      add(:id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true)
      add(:critic_name, :text, null: false)
      add(:critic_type, :text, null: false)
      add(:status, :text, null: false, default: "pending")
      add(:severity, :text, null: false, default: "info")
      add(:message, :text, null: false)
      add(:details, :map)
      add(:suggestions, {:array, :text}, default: [])
      add(:metadata, :map, default: %{})
      add(:created_at, :utc_datetime_usec, null: false, default: fragment("(now() AT TIME ZONE 'utc')"))
      add(:updated_at, :utc_datetime_usec, null: false, default: fragment("(now() AT TIME ZONE 'utc')"))
      add(:plan_id, :uuid)
      add(:task_id, :uuid)
    end

    create index(:validations, [:created_at])

    create index(:validations, [:critic_type])

    create index(:validations, [:status])

    create index(:validations, [:task_id])

    create index(:validations, [:plan_id])

    create table(:tasks, primary_key: false) do
      add(:id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true)
      add(:name, :text, null: false)
      add(:description, :text)
      add(:complexity, :text, null: false, default: "medium")
      add(:status, :text, null: false, default: "pending")
      add(:position, :bigint, null: false, default: 0)
      add(:success_criteria, :map)
      add(:validation_rules, :map)
      add(:execution_result, :map)
      add(:metadata, :map, default: %{})
      add(:created_at, :utc_datetime_usec, null: false, default: fragment("(now() AT TIME ZONE 'utc')"))
      add(:updated_at, :utc_datetime_usec, null: false, default: fragment("(now() AT TIME ZONE 'utc')"))
      add(:plan_id, :uuid, null: false)
    end

    create index(:tasks, [:plan_id, :position])

    create index(:tasks, [:position])

    create index(:tasks, [:status])

    create index(:tasks, [:plan_id])

    create table(:task_dependencies, primary_key: false) do
      add(:id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true)
      add(:created_at, :utc_datetime_usec, null: false, default: fragment("(now() AT TIME ZONE 'utc')"))

      add(
        :task_id,
        references(:tasks, column: :id, name: "task_dependencies_task_id_fkey", type: :uuid, prefix: "public"),
        null: false
      )

      add(
        :dependency_id,
        references(:tasks, column: :id, name: "task_dependencies_dependency_id_fkey", type: :uuid, prefix: "public"),
        null: false
      )
    end

    create index(:task_dependencies, [:task_id, :dependency_id], unique: true)

    create index(:task_dependencies, [:dependency_id])

    create index(:task_dependencies, [:task_id])

    create unique_index(:task_dependencies, [:task_id, :dependency_id],
             name: "task_dependencies_unique_dependency_index"
           )

    create table(:plans, primary_key: false) do
      add(:id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true)
    end

    alter table(:validations) do
      modify :plan_id, references(:plans, column: :id, name: "validations_plan_id_fkey", type: :uuid, prefix: "public")
      modify :task_id, references(:tasks, column: :id, name: "validations_task_id_fkey", type: :uuid, prefix: "public")
    end

    alter table(:tasks) do
      modify :plan_id, references(:plans, column: :id, name: "tasks_plan_id_fkey", type: :uuid, prefix: "public")
    end

    alter table(:plans) do
      add(:name, :text, null: false)
      add(:description, :text)
      add(:type, :text, null: false)
      add(:status, :text, null: false, default: "draft")
      add(:context, :map)
      add(:dependencies, :map)
      add(:constraints_data, :map)
      add(:validation_results, :map, default: %{})
      add(:execution_history, {:array, :map}, default: [])
      add(:metadata, :map, default: %{})
      add(:created_at, :utc_datetime_usec, null: false, default: fragment("(now() AT TIME ZONE 'utc')"))
      add(:updated_at, :utc_datetime_usec, null: false, default: fragment("(now() AT TIME ZONE 'utc')"))
    end

    create index(:plans, [:created_at])

    create index(:plans, [:type])

    create index(:plans, [:status])

    create unique_index(:plans, [:name], name: "plans_unique_name_index")

    create table(:constraints, primary_key: false) do
      add(:id, :uuid, null: false, default: fragment("gen_random_uuid()"), primary_key: true)
      add(:name, :text, null: false)
      add(:description, :text)
      add(:type, :text, null: false)
      add(:enforcement_level, :text, null: false, default: "hard")
      add(:scope, :text, null: false, default: "plan")
      add(:conditions, :map, null: false)
      add(:active, :boolean, null: false, default: true)
      add(:metadata, :map, default: %{})
      add(:created_at, :utc_datetime_usec, null: false, default: fragment("(now() AT TIME ZONE 'utc')"))
      add(:updated_at, :utc_datetime_usec, null: false, default: fragment("(now() AT TIME ZONE 'utc')"))

      add(:plan_id, references(:plans, column: :id, name: "constraints_plan_id_fkey", type: :uuid, prefix: "public"),
        null: false
      )
    end

    create index(:constraints, [:enforcement_level])

    create index(:constraints, [:type])

    create index(:constraints, [:plan_id])
  end

  def down do
    drop(constraint(:constraints, "constraints_plan_id_fkey"))

    drop_if_exists(index(:constraints, [:plan_id]))

    drop_if_exists(index(:constraints, [:type]))

    drop_if_exists(index(:constraints, [:enforcement_level]))

    drop(table(:constraints))

    drop_if_exists(unique_index(:plans, [:name], name: "plans_unique_name_index"))

    drop_if_exists(index(:plans, [:status]))

    drop_if_exists(index(:plans, [:type]))

    drop_if_exists(index(:plans, [:created_at]))

    alter table(:plans) do
      remove(:updated_at)
      remove(:created_at)
      remove(:metadata)
      remove(:execution_history)
      remove(:validation_results)
      remove(:constraints_data)
      remove(:dependencies)
      remove(:context)
      remove(:status)
      remove(:type)
      remove(:description)
      remove(:name)
    end

    drop(constraint(:tasks, "tasks_plan_id_fkey"))

    alter table(:tasks) do
      modify :plan_id, :uuid
    end

    drop(constraint(:validations, "validations_plan_id_fkey"))

    drop(constraint(:validations, "validations_task_id_fkey"))

    alter table(:validations) do
      modify :task_id, :uuid
      modify :plan_id, :uuid
    end

    drop(table(:plans))

    drop_if_exists(
      unique_index(:task_dependencies, [:task_id, :dependency_id], name: "task_dependencies_unique_dependency_index")
    )

    drop(constraint(:task_dependencies, "task_dependencies_task_id_fkey"))

    drop(constraint(:task_dependencies, "task_dependencies_dependency_id_fkey"))

    drop_if_exists(index(:task_dependencies, [:task_id]))

    drop_if_exists(index(:task_dependencies, [:dependency_id]))

    drop_if_exists(index(:task_dependencies, [:task_id, :dependency_id]))

    drop(table(:task_dependencies))

    drop_if_exists(index(:tasks, [:plan_id]))

    drop_if_exists(index(:tasks, [:status]))

    drop_if_exists(index(:tasks, [:position]))

    drop_if_exists(index(:tasks, [:plan_id, :position]))

    drop(table(:tasks))

    drop_if_exists(index(:validations, [:plan_id]))

    drop_if_exists(index(:validations, [:task_id]))

    drop_if_exists(index(:validations, [:status]))

    drop_if_exists(index(:validations, [:critic_type]))

    drop_if_exists(index(:validations, [:created_at]))

    drop(table(:validations))
  end
end
