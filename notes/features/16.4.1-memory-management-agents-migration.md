# Feature: Memory Management Agents Migration (16.4.1)

## Summary
Migrate MemoryCoordinatorAgent and LongTermMemoryAgent from BaseAgent to pure Jido.Agent architecture with proper Action-based design.

## Requirements
### 16.4.1.1 Fix MemoryCoordinatorAgent
- [ ] Remove legacy signal handling and BaseAgent dependency
- [ ] Extract memory operations into Actions
- [ ] Implement distributed coordination
- [ ] Add consistency and synchronization
- [ ] Create memory optimization

### 16.4.1.2 Fix LongTermMemoryAgent  
- [ ] Convert mixed patterns to pure Jido
- [ ] Extract storage operations into Actions
- [ ] Implement search and indexing
- [ ] Add archival and compression
- [ ] Create backup and recovery

## Research Summary

### Current Implementation Analysis
Both agents currently use `RubberDuck.Agents.BaseAgent` with inline signal handling logic.

**MemoryCoordinatorAgent:**
- Handles 6 signal types: memory_operation_request, sync_memory_tiers, memory_health_check, create_memory_partition, memory_access_request, get_coordination_metrics
- Contains inline business logic for coordination, synchronization, partitioning
- Manages distributed memory operations across tiers

**LongTermMemoryAgent:**
- Manages persistent storage with multiple backends
- Contains indexing, versioning, and search capabilities
- Has complex state management for cache, pending writes, versions

### Technical Approach

#### MemoryCoordinatorAgent Migration:
1. Convert to `use Jido.Agent`
2. Extract into Actions:
   - `CoordinateOperationAction` - Handle cross-tier operations
   - `SyncMemoryTiersAction` - Synchronize memory across tiers  
   - `CheckMemoryHealthAction` - Monitor system health
   - `CreatePartitionAction` - Create memory partitions
   - `HandleAccessRequestAction` - Access control decisions
   - `GetCoordinationMetricsAction` - Performance metrics

#### LongTermMemoryAgent Migration:
1. Convert to `use Jido.Agent`
2. Extract into Actions:
   - `StoreMemoryAction` - Persistent storage operations
   - `RetrieveMemoryAction` - Memory retrieval with caching
   - `SearchMemoryAction` - Advanced search and indexing
   - `VersionMemoryAction` - Version control operations
   - `OptimizeStorageAction` - Storage lifecycle management
   - `BackupMemoryAction` - Backup and recovery operations

## Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|------------|
| Breaking memory coordination | High | Maintain same signal interfaces |
| Loss of distributed state | High | Preserve state structure in migration |
| Performance degradation | Medium | Profile memory operations before/after |
| Cache invalidation issues | Medium | Implement proper cache management in Actions |

## Implementation Checklist
- [ ] Backup original agents
- [ ] Create MemoryCoordinatorAgent with Jido.Agent
- [ ] Define coordination Actions
- [ ] Implement signal routing for coordinator
- [ ] Create LongTermMemoryAgent with Jido.Agent
- [ ] Define storage Actions
- [ ] Implement signal routing for storage
- [ ] Test memory operations
- [ ] Verify distributed coordination
- [ ] Update documentation

## Questions for Pascal
1. Should we maintain the exact same memory tier architecture?
2. Are there specific performance requirements for memory operations?
3. Should the cache be managed within Actions or at the agent level?
4. Do we need to maintain backward compatibility with existing memory APIs?