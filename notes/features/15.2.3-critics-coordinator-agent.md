# Feature: Critics Coordinator Agent (15.2.3)

## Summary
Transform the existing Critics Orchestrator into a Jido Agent that coordinates multiple critic agents to validate plans and tasks using signal-based communication.

## Context
The current Critics Orchestrator is a module-based system that runs critics in parallel or sequentially. We need to transform this into an agent-based architecture where:
- The coordinator is a Jido Agent
- Individual critics can be agents or modules
- Communication happens through signals
- Results are aggregated asynchronously

## Requirements
Based on section 15.2.3 of the refactor plan:

### 15.2.3.1 Create Coordinator Agent Module
- Implement RubberDuck.Agents.CriticsCoordinatorAgent
- Transform orchestrator logic to agent patterns
- Add signal-based coordination
- Create state management for active validations
- Implement result aggregation

### 15.2.3.2 Implement Critic Discovery
- Create critic registration system
- Add dynamic discovery of available critics
- Implement capability queries
- Create critic selection logic
- Add load balancing for distributed critics

### 15.2.3.3 Build Parallel Execution System
- Create work distribution mechanism
- Implement timeout handling
- Add result collection
- Create error aggregation
- Implement retry logic

### 15.2.3.4 Add Result Processing
- Create result normalization
- Implement severity calculation
- Add recommendation aggregation
- Create summary generation
- Implement caching

### 15.2.3.5 Create Coordination Metrics
- Track critic performance
- Monitor execution times
- Add accuracy metrics
- Create resource tracking
- Implement trend analysis

## Technical Approach

### Agent Architecture
```elixir
use RubberDuck.Agents.BaseAgent,
  name: "critics_coordinator_agent",
  description: "Coordinates validation critics for plans and tasks",
  schema: [
    active_validations: [type: :map, default: %{}],
    critic_registry: [type: :map, default: %{}],
    cache: [type: :map, default: %{}],
    cache_enabled: [type: :boolean, default: true],
    parallel_execution: [type: :boolean, default: true],
    timeout: [type: :integer, default: 30_000],
    max_retries: [type: :integer, default: 3]
  ]
```

### Signal Interface

#### Input Signals
- `validate_target` - Request validation of a plan or task
  - Required: `target_type`, `target_id`, `target_data`
  - Optional: `critic_types`, `priority`, `timeout`
  
- `register_critic` - Register a new critic agent
  - Required: `critic_id`, `critic_type`, `capabilities`
  
- `unregister_critic` - Remove a critic from registry
  - Required: `critic_id`

#### Output Signals  
- `validation_started` - Validation process begun
- `critic_assigned` - Work assigned to specific critic
- `validation_progress` - Progress updates
- `validation_complete` - Final aggregated results
- `validation_failed` - Error during validation

### State Management
- Track active validations with their status
- Maintain registry of available critics
- Cache validation results with TTL
- Store performance metrics per critic

### Implementation Strategy

1. **Phase 1: Core Agent Structure**
   - Create agent module with state schema
   - Implement basic signal handlers
   - Add validation tracking

2. **Phase 2: Critic Management**
   - Build critic registry
   - Implement discovery mechanism
   - Add capability matching

3. **Phase 3: Execution System**
   - Create work distribution logic
   - Implement parallel execution
   - Add timeout and retry handling

4. **Phase 4: Result Processing**
   - Build result aggregation
   - Implement caching
   - Add summary generation

5. **Phase 5: Metrics & Monitoring**
   - Add performance tracking
   - Implement analytics
   - Create reporting signals

## Risks and Mitigations

### Risk: Critic Agent Communication Overhead
- **Mitigation**: Support both agent-based and module-based critics
- **Mitigation**: Batch validation requests when possible

### Risk: Result Consistency
- **Mitigation**: Implement result versioning
- **Mitigation**: Add conflict resolution for contradictory validations

### Risk: Performance Degradation
- **Mitigation**: Aggressive caching strategy
- **Mitigation**: Load balancing across critic instances

### Risk: Critic Failures
- **Mitigation**: Retry logic with exponential backoff
- **Mitigation**: Fallback to alternate critics

## Implementation Checklist

- [ ] Create CriticsCoordinatorAgent module
- [ ] Define agent schema and state
- [ ] Implement signal handlers
- [ ] Create critic registry system
- [ ] Build discovery mechanism
- [ ] Implement work distribution
- [ ] Add parallel execution support
- [ ] Create result aggregation
- [ ] Implement caching layer
- [ ] Add performance metrics
- [ ] Write comprehensive tests
- [ ] Document signal interface

## Dependencies
- Existing Critics modules (HardCritic, SoftCritic, etc.)
- BaseAgent for common agent patterns
- Jido.Agent for agent framework
- Existing Validation Ash resource

## Questions for Pascal
1. Should we maintain backward compatibility with the module-based Orchestrator?
2. Do you want critics to be full agents or can they remain modules?
3. What level of caching granularity - per target or per critic result?
4. Should validation results be persisted to the database?
5. Do you need real-time progress for long-running validations?

## Log
- Started feature planning based on section 15.2.3 requirements
- Analyzed existing Orchestrator implementation  
- Reviewed CriticBehaviour interface
- Identified key components to transform: parallel execution, caching, result aggregation
- Designed signal-based interface for coordination
- Created CriticsCoordinatorAgent with full signal-based coordination
- Implemented critic registry for dynamic critic management
- Built parallel and sequential execution modes
- Added result aggregation with severity calculation
- Implemented caching with TTL support
- Added comprehensive metrics tracking
- Created SyntaxValidatorAgent as example critic agent
- Added integration tests demonstrating agent coordination
- All tests passing