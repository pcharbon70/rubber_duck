# Feature: Signal Taxonomy (16.6.1)

## Summary
Create a comprehensive signal taxonomy and routing system for the RubberDuck platform, establishing standardized signal categories and implementing intelligent routing rules. All signals will be proper Jido signals using CloudEvents specification.

## Requirements
- [ ] Define standardized signal categories with clear semantics
- [ ] Implement signal routing rules with pattern matching
- [ ] Create priority-based delivery mechanisms
- [ ] Add load balancing and failover strategies
- [ ] Implement dead letter handling for failed signals
- [ ] Ensure all signals are CloudEvents-compliant via Jido.Signal
- [ ] Provide type safety through schemas
- [ ] Enable efficient signal filtering and routing

## Research Summary

### Existing Patterns Found
- **EmitSignalAction**: Shows proper Jido.Signal.new/1 and Bus.publish patterns
- **Signal Naming**: Hierarchical convention (e.g., "token.budget.created")
- **CloudEvents**: All signals must be CloudEvents-compliant
- **Signal Bus**: RubberDuck.SignalBus for centralized publishing

### Jido Signal Requirements
- Signals created with `Jido.Signal.new/1`
- Published via `Jido.Signal.Bus.publish/2`
- Must include: type, source, data
- Optional: subject, extensions
- Automatic ID and timestamp generation

### Technical Approach

1. **Signal Categories**:
   - **Request Signals**: Initiate actions/workflows (*.request)
   - **Event Signals**: State changes/occurrences (*.created, *.updated, *.deleted)
   - **Command Signals**: Direct imperatives (*.execute, *.stop, *.restart)
   - **Query Signals**: Information retrieval (*.query, *.fetch)
   - **Notification Signals**: Alerts/updates (*.notify, *.alert, *.warning)

2. **Signal Structure**:
   ```elixir
   %{
     category: :request | :event | :command | :query | :notification,
     domain: String.t(),  # e.g., "analysis", "generation", "memory"
     action: String.t(),  # e.g., "create", "update", "execute"
     priority: :low | :normal | :high | :critical,
     routing_key: String.t(),  # Pattern for routing
     metadata: map()
   }
   ```

3. **Routing Rules**:
   - Pattern-based matching on signal type
   - Priority queues for delivery order
   - Round-robin load balancing for handlers
   - Automatic failover with retry logic
   - Dead letter queue for undeliverable signals

## Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|------------|
| Performance overhead from routing | Medium | Use ETS for fast pattern matching |
| Signal ordering issues | High | Implement sequence numbers and ordering guarantees |
| Memory usage from dead letters | Medium | Implement TTL and cleanup policies |
| Breaking existing signal patterns | High | Maintain backward compatibility layer |

## Implementation Checklist
- [ ] Create `lib/rubber_duck/jido/signals/` directory structure
- [ ] Implement `SignalCategory` module with category definitions
- [ ] Create `SignalRouter` for pattern-based routing
- [ ] Implement `SignalPriority` for priority handling
- [ ] Create `SignalLoadBalancer` for distribution strategies
- [ ] Implement `DeadLetterQueue` for failed signals
- [ ] Add `SignalValidator` for schema validation
- [ ] Create `SignalMetrics` for monitoring
- [ ] Write comprehensive tests
- [ ] Update documentation

## Questions for Pascal
1. Should we support custom signal categories beyond the five defined?
2. What should be the default priority for each category?
3. How long should signals remain in the dead letter queue?
4. Should routing rules be configurable at runtime?