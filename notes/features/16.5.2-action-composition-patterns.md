# Feature: Action Composition Patterns (16.5.2)

## Summary
Implement advanced action composition patterns and middleware system to enable complex workflows, cross-cutting concerns, and sophisticated signal-based coordination using proper Jido signals and architecture.

## Requirements
- [ ] Create workflow actions for sequential, parallel, and conditional execution
- [ ] Implement proper error handling with retry and recovery mechanisms
- [ ] Build middleware system for cross-cutting concerns (logging, auth, rate limiting, caching)
- [ ] Ensure all signals are proper Jido signals using Jido.Signal
- [ ] Maintain compatibility with existing ComposeAction and base action modules
- [ ] Provide telemetry and monitoring capabilities
- [ ] Support async/await patterns for long-running operations
- [ ] Enable signal-based coordination between composed actions

## Research Summary

### Existing Usage Rules Checked
- **Jido Framework**: Actions must be pure functions, use tagged tuples, support composition through proper patterns
- **Jido Signals**: Use Jido.Signal.new/1 for creating CloudEvents-compliant signals, Jido.Signal.Bus.publish/2 for emission
- **Reactor Integration**: Existing WorkflowMiddleware shows telemetry patterns for workflow execution

### Documentation Reviewed
- **ComposeAction**: Already provides basic sequential/parallel execution with error handling
- **EmitSignalAction**: Shows proper Jido signal creation and bus publication patterns
- **WorkflowMiddleware**: Demonstrates Reactor middleware integration for workflow telemetry

### Existing Patterns Found
- **ComposeAction**: `lib/rubber_duck/jido/actions/base/compose_action.ex` - Basic composition with sequential/parallel
- **Signal Emission**: `lib/rubber_duck/jido/actions/base/emit_signal_action.ex` - Proper Jido signal patterns
- **Middleware Example**: `lib/rubber_duck/jido/agents/workflow_middleware.ex` - Reactor middleware for telemetry
- **Base Actions**: Recently created base action modules provide hooks for middleware integration

### Technical Approach

1. **Enhance Workflow Actions**:
   - Build on existing ComposeAction to add more sophisticated patterns
   - Create specialized workflow actions (Pipeline, Fanout, Saga, Circuit)
   - Add conditional branching with signal-based decisions
   - Implement retry strategies with exponential backoff
   - Add compensation/rollback for saga patterns

2. **Implement Middleware System**:
   - Create middleware protocol for action interception
   - Build middleware chain execution with proper ordering
   - Implement standard middleware (logging, auth, rate limiting, caching, monitoring)
   - Support both sync and async middleware
   - Enable middleware composition and configuration

3. **Signal-Based Coordination**:
   - Use Jido.Signal for all inter-action communication
   - Implement signal routing between composed actions
   - Add signal transformation and enrichment
   - Support signal-based conditional execution
   - Enable async signal handling with proper acknowledgment

## Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|------------|
| Performance overhead from middleware | Medium | Use lightweight middleware, benchmark critical paths |
| Complex debugging with nested composition | High | Add comprehensive telemetry and tracing |
| Signal ordering issues in parallel execution | Medium | Implement proper signal sequencing and correlation |
| Breaking existing ComposeAction usage | High | Extend rather than replace, maintain backward compatibility |

## Implementation Checklist
- [ ] Create `lib/rubber_duck/jido/actions/workflow/` directory structure
- [ ] Implement `PipelineAction` for sequential data transformation
- [ ] Implement `FanoutAction` for parallel broadcast execution
- [ ] Implement `SagaAction` for distributed transactions with compensation
- [ ] Implement `CircuitAction` for circuit breaker patterns
- [ ] Create `lib/rubber_duck/jido/actions/middleware/` directory structure
- [ ] Implement middleware protocol and chain execution
- [ ] Create `LoggingMiddleware` with structured logging
- [ ] Create `AuthMiddleware` for authentication/authorization
- [ ] Create `RateLimitMiddleware` with token bucket algorithm
- [ ] Create `CacheMiddleware` with TTL and invalidation
- [ ] Create `MonitoringMiddleware` with metrics collection
- [ ] Add signal-based coordination utilities
- [ ] Create comprehensive test suite
- [ ] Update documentation with examples

## Questions for Pascal
1. Should middleware be applied globally to all actions or configurable per action?
2. Do you want middleware to modify action parameters/results or just observe?
3. Should we support middleware ordering/priority configuration?
4. How should middleware handle async operations and long-running tasks?