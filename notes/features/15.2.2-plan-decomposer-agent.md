# Feature: Plan Decomposer Agent

## Summary
Transform the existing TaskDecomposer engine into a Jido Agent that breaks down high-level plans into actionable tasks using signal-based communication and agent patterns.

## Requirements
- [ ] Create RubberDuck.Agents.PlanDecomposerAgent using Jido.Agent
- [ ] Migrate existing TaskDecomposer functionality to agent-based architecture
- [ ] Implement signal-based interface for decomposition requests/responses
- [ ] Support hierarchical decomposition with phase detection
- [ ] Add parallel decomposition capabilities for independent tasks
- [ ] Implement decomposition strategies (linear, hierarchical, tree-of-thought)
- [ ] Create quality assurance checks for decomposition validation
- [ ] Integrate with existing Plan and Task Ash resources
- [ ] Add caching for repeated decomposition patterns
- [ ] Ensure proper error handling and state management

## Research Summary
### Existing Usage Rules Checked
- Jido.Agent usage rules: 
  - Use schemas for parameter validation
  - Implement signal handlers for agent communication
  - Follow OTP supervision patterns
  - Use lifecycle hooks for state validation
  - Return tagged tuples consistently
  - Keep actions focused and pure

### Documentation Reviewed
- Jido v1.2.0: Agent framework emphasizes functional programming with OTP reliability
- Existing TaskDecomposer: Uses LLM-guided decomposition with validation
- RubberDuck.Agents.BaseAgent: Provides common agent patterns and utilities

### Existing Patterns Found
- TaskDecomposer pattern: `/home/ducky/code/rubber_duck/lib/rubber_duck/planning/task_decomposer.ex` - Engine-based implementation with strategies
- BaseAgent pattern: `/home/ducky/code/rubber_duck/lib/rubber_duck/agents/base_agent.ex` - Shows signal handling and state management
- Plan/Task resources: Already have Ash resources for persistence

### Technical Approach
1. **Agent Structure**:
   - Use Jido.Agent with schema for state validation
   - Define signals for decomposition requests/responses
   - Implement lifecycle hooks for initialization and validation

2. **State Management**:
   - Track active decompositions in agent state
   - Cache decomposition results for pattern reuse
   - Maintain strategy preferences and metrics

3. **Signal Interface**:
   - `decompose_plan` signal: Initiates decomposition with plan details
   - `decomposition_progress` signal: Reports progress updates
   - `decomposition_complete` signal: Returns decomposed tasks
   - `decomposition_failed` signal: Reports errors

4. **Decomposition Logic**:
   - Port existing strategies from TaskDecomposer
   - Add phase detection for hierarchical organization
   - Implement parallel task identification
   - Integrate with LLM service for intelligent decomposition

5. **Quality Assurance**:
   - Validate task completeness
   - Check for circular dependencies
   - Ensure proper task ordering
   - Verify resource requirements

## Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|------------|
| LLM response variability | High | Implement validation and retry logic with fallback strategies |
| Circular dependencies | Medium | Add dependency graph analysis and cycle detection |
| Performance with large plans | Medium | Implement caching and batch processing |
| State consistency during failures | High | Use OTP supervision and state recovery patterns |

## Implementation Checklist
- [ ] Create `/lib/rubber_duck/agents/plan_decomposer_agent.ex` with Jido.Agent structure
- [ ] Define agent schema with state fields (active_decompositions, cache, strategies)
- [ ] Implement signal handlers for decomposition requests
- [ ] Port decomposition strategies from TaskDecomposer
- [ ] Create decomposition actions as separate Jido.Action modules
- [ ] Add phase detection and hierarchical organization
- [ ] Implement parallel task identification logic
- [ ] Create quality validation functions
- [ ] Add integration with Plan/Task Ash resources
- [ ] Write comprehensive tests for agent behavior
- [ ] Test signal-based communication patterns
- [ ] Verify error handling and recovery
- [ ] Document signal interface and usage patterns

## Questions for Pascal
1. Should we maintain backward compatibility with the existing TaskDecomposer interface?
2. What level of caching granularity do you prefer - full plans or individual decomposition patterns?
3. Should the agent automatically persist decomposed tasks to the database or return them for the caller to persist?
4. Do you want real-time progress updates during decomposition or just final results?
5. Should we implement a priority queue for handling multiple concurrent decomposition requests?

## Log
- Started feature planning based on section 15.2.2 requirements
- Researched Jido Agent documentation and usage rules
- Reviewed existing TaskDecomposer implementation for migration patterns
- Analyzed BaseAgent patterns for RubberDuck-specific agent implementation
- Identified key components to port: strategies, validation, templates
- Mapped existing engine-based architecture to agent-based signal pattern
- Created PlanDecomposerAgent module with Jido.Agent structure
- Implemented signal handlers for decompose_plan, progress, complete, and failed signals
- Created three decomposer action modules: LinearDecomposer, HierarchicalDecomposer, TreeOfThoughtDecomposer
- Ported all decomposition logic from TaskDecomposer to new actions
- Added caching support with TTL
- Implemented async decomposition processing with Task.start
- Created comprehensive test suite covering all major functionality
- All tests passing successfully

## Current Status
- Core agent implementation complete
- Signal-based interface working
- All three decomposition strategies ported
- Caching implemented
- Tests passing
- Ash resource integration added for Plans and Tasks
- Automatic persistence to database when decomposition completes

## Ash Integration Details
- Added `persist_to_db` configuration option (defaults to true)
- When decomposition completes, tasks are automatically created in the database
- Plan status is updated to :ready when decomposition completes
- Plan metadata is enriched with decomposition information
- Tasks are properly linked to their parent plan
- Integration tests verify persistence works correctly

## Next Steps
- Add more robust error handling and recovery (transaction support)
- Implement progress tracking for long-running decompositions
- Add telemetry and metrics
- Document the signal interface
- Add support for updating existing decompositions

## Completed Features
- ✅ Core agent implementation with Jido.Agent
- ✅ Signal-based communication interface
- ✅ Three decomposition strategies (linear, hierarchical, tree-of-thought)
- ✅ Caching with TTL
- ✅ Ash resource integration for Plans and Tasks
- ✅ TaskDependency creation and persistence
- ✅ Comprehensive test coverage