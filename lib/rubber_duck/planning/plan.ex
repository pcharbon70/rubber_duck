defmodule RubberDuck.Planning.Plan do
  @moduledoc """
  Represents a high-level plan in the planning system.
  
  Plans are generated by LLMs and validated by external critics. They contain
  context, dependencies, constraints, and can be decomposed into tasks.
  """
  
  use Ash.Resource,
    otp_app: :rubber_duck,
    domain: RubberDuck.Planning,
    data_layer: AshPostgres.DataLayer
  
  postgres do
    table "plans"
    repo RubberDuck.Repo
    
    custom_indexes do
      index [:status]
      index [:type]
      index [:created_at]
    end
  end
  
  actions do
    defaults [:read, :destroy]
    
    create :create do
      primary? true
      accept [:name, :description, :type, :context, :dependencies, :constraints_data, :metadata]
      
      change set_attribute(:status, :draft)
      change set_attribute(:created_at, &DateTime.utc_now/0)
      change set_attribute(:updated_at, &DateTime.utc_now/0)
    end
    
    update :update do
      primary? true
      accept [:name, :description, :type, :status, :context, :dependencies, :constraints_data, :metadata]
      
      change set_attribute(:updated_at, &DateTime.utc_now/0)
    end
    
    update :transition_status do
      accept [:status]
      
      argument :new_status, :atom do
        allow_nil? false
        constraints one_of: [:draft, :ready, :executing, :completed, :failed]
      end
      
      change set_attribute(:status, arg(:new_status))
      change set_attribute(:updated_at, &DateTime.utc_now/0)
    end
    
    update :add_validation_result do
      accept []
      require_atomic? false
      
      argument :validation_results, :map do
        allow_nil? false
      end
      
      change fn changeset, _ ->
        current_results = Ash.Changeset.get_attribute(changeset, :validation_results) || %{}
        new_results = Map.merge(current_results, changeset.arguments.validation_results)
        
        Ash.Changeset.change_attribute(changeset, :validation_results, new_results)
      end
      
      change set_attribute(:updated_at, &DateTime.utc_now/0)
    end
    
    update :record_execution do
      accept []
      require_atomic? false
      
      argument :execution_entry, :map do
        allow_nil? false
      end
      
      change fn changeset, _ ->
        current_history = Ash.Changeset.get_attribute(changeset, :execution_history) || []
        new_entry = Map.put(changeset.arguments.execution_entry, :timestamp, DateTime.utc_now())
        
        Ash.Changeset.change_attribute(changeset, :execution_history, [new_entry | current_history])
      end
      
      change set_attribute(:updated_at, &DateTime.utc_now/0)
    end
    
    read :list_by_status do
      argument :status, :atom do
        allow_nil? false
        constraints one_of: [:draft, :ready, :executing, :completed, :failed]
      end
      
      filter expr(status == ^arg(:status))
    end
    
    read :list_by_type do
      argument :type, :atom do
        allow_nil? false
        constraints one_of: [:feature, :refactor, :bugfix, :analysis, :migration]
      end
      
      filter expr(type == ^arg(:type))
    end
  end
  
  attributes do
    uuid_primary_key :id
    
    attribute :name, :string do
      allow_nil? false
      public? true
      description "Human-readable name for the plan"
    end
    
    attribute :description, :string do
      allow_nil? true
      public? true
      description "Detailed description of what this plan accomplishes"
    end
    
    attribute :type, :atom do
      allow_nil? false
      public? true
      constraints one_of: [:feature, :refactor, :bugfix, :analysis, :migration]
      description "The type of plan"
    end
    
    attribute :status, :atom do
      allow_nil? false
      public? true
      default :draft
      constraints one_of: [:draft, :ready, :executing, :completed, :failed]
      description "Current status of the plan"
    end
    
    attribute :context, :map do
      allow_nil? true
      public? true
      description "Project context including files, dependencies, and environment"
    end
    
    attribute :dependencies, :map do
      allow_nil? true
      public? true
      description "External dependencies and requirements"
    end
    
    attribute :constraints_data, :map do
      allow_nil? true
      public? true
      description "Constraint specifications for this plan"
    end
    
    attribute :validation_results, :map do
      allow_nil? true
      public? true
      default %{}
      description "Results from critic validations"
    end
    
    attribute :execution_history, {:array, :map} do
      allow_nil? true
      public? true
      default []
      description "History of execution attempts and results"
    end
    
    attribute :metadata, :map do
      allow_nil? true
      public? true
      default %{}
      description "Additional metadata for the plan"
    end
    
    create_timestamp :created_at
    update_timestamp :updated_at
  end
  
  relationships do
    has_many :tasks, RubberDuck.Planning.Task do
      destination_attribute :plan_id
      sort :position
    end
    
    has_many :constraints, RubberDuck.Planning.Constraint do
      destination_attribute :plan_id
    end
    
    has_many :validations, RubberDuck.Planning.Validation do
      destination_attribute :plan_id
      sort :created_at
    end
  end
  
  identities do
    identity :unique_name, [:name]
  end
  
  calculations do
    calculate :task_count, :integer, expr(count(tasks))
    
    calculate :ready_task_count, :integer do
      calculation fn records, _opts ->
        Enum.map(records, fn record ->
          record.tasks
          |> Enum.count(& &1.status == :ready)
        end)
      end
    end
    
    calculate :completed_task_count, :integer do
      calculation fn records, _opts ->
        Enum.map(records, fn record ->
          record.tasks
          |> Enum.count(& &1.status == :completed)
        end)
      end
    end
    
    calculate :progress_percentage, :float do
      calculation fn records, _opts ->
        Enum.map(records, fn record ->
          total = length(record.tasks)
          if total == 0 do
            0.0
          else
            completed = Enum.count(record.tasks, & &1.status == :completed)
            Float.round(completed / total * 100, 2)
          end
        end)
      end
    end
    
    calculate :validation_status, :atom do
      calculation fn records, _opts ->
        Enum.map(records, fn record ->
          cond do
            Enum.empty?(record.validations) -> :pending
            Enum.any?(record.validations, & &1.status == :failed) -> :failed
            Enum.all?(record.validations, & &1.status == :passed) -> :passed
            true -> :warning
          end
        end)
      end
    end
  end
end